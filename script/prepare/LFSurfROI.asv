function ROI_tri_idx = LFSurfROI(dataRoot,subMark,ROIinfo)
% define leadfield in gray matter surface
% atlas: "'DK40'" or "MNI_Coord" in simNIBS
LFPath = fullfile(dataRoot,subMark,'leadfield');
LFFile = fullfile(LFPath,[subMark '_leadfield_EEG10-10_UI_Jurak_2007.hdf5']);
if exist(LFFile,'file')~=2
    error('Leadfield file for gray matter surface not existed! Please run prepare script.');
end
LF0 = mesh_load_hdf5(LFFile);
m0 = LF0(2).mesh;
node_1006_idx = unique(m0.triangles(m0.triangle_regions==1006,:));
m = mesh_extract_regions(SurfMesh, 'region_idx', [1 2]); % gray matter surface in both hemisphere
areas = mesh_get_node_areas(m);
TR = triangulation(double(m.triangles),m.nodes);
nt = vertexNormal(TR);
%% ROI_tri_idx
m2mPath = fullfile(dataRoot,subMark, ['m2m_' subMark]);
switch ROIinfo.type
    case 'atlas'
        disp(['Define ROI using atlas ' ROIinfo.atlas '...']);
        [labels, snames] = subject_atlas(m, m2mPath, ROIinfo.atlas);
        ROI_idx = find(strcmpi(snames, ROIinfo.name));
        if isempty(ROI_idx)
            error('No corresponding ROI name for this atlas!');
        else
            ROI_node_idx = labels.node_data{1}.data == ROI_idx;
            ROI_tri_idx = find(any(TR.ConnectivityList(ROI_node_idx),2));
        end
    case 'coord'
        disp('Define ROI using MNI coordinates ... ');
        coord_sub = mni2subject_coords(ROIinfo.coord_MNI, m2mPath);%坐标转换
        center_tri = incenter(TR);
        ROI_tri_idx = unique(dsearchn(center_tri,coord_sub));
    otherwise
        error('Wrong ROI type!');
end
%% extract LF
LF.electrodes = LF0(2).lf.properties.electrode_names; %电极名称
Ne = size(LF.electrodes,1); %电极数目
n = size(LF0(2).mesh.nodes,1);
E = zeros(n,3,76);
E(:,:,2:end) = permute(LF0(2).lf.data,[2,1,3]);
E(node_1006_idx,:,:)=[];
% LF.NA_ROI = single(nodes_areas(LF.ROI_idx,:)); % node areas
% LF.NA_Cortex = single(nodes_areas(LF.OutROI_idx,:));
%
% LF.E = zeros(size(LF0(2).mesh.nodes,1),3,N);
% LF.E_ROI = zeros(sum(LF.ROI_idx,1),3,N);
% LF.E_Cortex = zeros(sum(LF.OutROI_idx,1),3,N);
% for i = 2:N  %第一个电极是Cz，是参考电极，没有值
%     LF.E(:,:,i) = lf(2).lf.data(:,:,i-1).';
% end
% LF.E = LF.E(1:size(m.nodes,1),:,:)./1000;%不除1000会显存溢出
%
% for j = 2:N
%     LF.E_ROI(:,:,j) = LF.E(LF.ROI_idx,:,j);
%     LF.E_Cortex(:,:,j) = LF.E(LF.OutROI_idx,:,j);
% end
% LF.c0 = int32(nchoosek(1:N,4));
% LF.E_ROI = single(LF.E_ROI);
% LF.E_Cortex = single(LF.E_Cortex);
%
% LF.Cortex_coef(LF.Cortex_coef == false) = [];
% LF.Cortex_coef = repmat(LF.Cortex_coef,1,size(LF.E_Cortex,2),size(LF.E_Cortex,3));
% LF.E_Cortex = LF.E_Cortex.*LF.Cortex_coef;%可以把Cortex.penalty设置为>1的数值，增大对想要排除的脑区的惩罚
%% penalty

%% orientation

%% save

%% 提取ROI和Cortex的Index
%% 扩大ROI的边缘区域,这一步两种方法都要做
% 将ROI区域向外扩展的倍数，超出ROI的区域在计算过程中被“抠除”
% ROI区域为 1234，超出区域被标为 5678

%% 提取E_ROI,E_Cortex

% % save(fullfile(path4save,'LF.mat'),'LF');
% cd(currentdir);



